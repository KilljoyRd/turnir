<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Учёт турнира — автономный файл</title>
  <style>
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    :root{
      --bg:#0b0b0b;
      --card:#141414;
      --card2:#101010;
      --border:#2b2b2b;
      --text:#f2f2f2;
      --muted:#bdbdbd;
      --gold:#FFC400;
      --gold2:#FFB000;
      --danger:#4a1616;
      --danger2:#6a1d1d;
      --row:#121212;
      --row2:#151515;
      --shadow:0 10px 30px rgba(0,0,0,.55);
      --radius:18px;
      --btnH:44px;
      --gap:18px;
    }

    body{
      margin:0;
      background:
        radial-gradient(ellipse at top, rgba(255,196,0,.08), transparent 42%),
        radial-gradient(ellipse at bottom, rgba(255,196,0,.05), transparent 55%),
        var(--bg);
      color:var(--text);
      font-family:"PT Sans", "Trebuchet MS", sans-serif;
    }

    .container{
      max-width:1280px;
      margin:0 auto;
      padding:24px 18px 36px;
    }

    .mainGrid{
      display:grid;
      grid-template-columns: 420px minmax(0, 1fr);
      gap:var(--gap);
      align-items:start;
    }

    .leftCol,.rightCol{ width:100%; min-width:0; }
    .rightCol{ min-width:0; }

    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:var(--radius);
      padding:18px;
      box-shadow:var(--shadow);
      margin-bottom:var(--gap);
    }

    .cardTitle{
      margin:0 0 14px 0;
      font-size:18px;
      letter-spacing:.4px;
      color:var(--gold);
    }

    .row{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:12px;
      align-items:end;
    }

    .field{
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    label{ font-size:12px; color:var(--muted); }

    input, select, textarea{
      background:var(--card2);
      border:1px solid var(--border);
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      font-size:14px;
      outline:none;
    }

    input:focus, select:focus, textarea:focus{ border-color:var(--gold); }

    .btn{
      height:var(--btnH);
      padding:0 16px;
      border-radius:12px;
      border:1px solid transparent;
      font-weight:700;
      letter-spacing:.2px;
      cursor:pointer;
      transition:transform .05s ease, box-shadow .2s ease, background .2s ease, border .2s ease;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      user-select:none;
      text-align:center;
      white-space:nowrap;
    }

    .btnPrimary{
      background:var(--gold);
      color:#111;
      box-shadow:0 8px 18px rgba(255,196,0,.22);
    }

    .btnPrimary:hover{ background:var(--gold2); }

    .btnSecondary{
      background:transparent;
      color:var(--gold);
      border-color:var(--gold);
    }

    .btnSecondary:hover{
      background:rgba(255,196,0,.12);
      box-shadow:0 8px 18px rgba(255,196,0,.12);
    }

    .btnDanger{
      background:var(--danger);
      color:#ffd7d7;
      border-color:var(--danger2);
    }

    .btnDanger:hover{ background:var(--danger2); }

    .btn[disabled]{ opacity:.5; cursor:not-allowed; box-shadow:none; }

    .btnGrid2{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
      margin-top:12px;
    }

    .btnGrid1{
      display:grid;
      grid-template-columns:1fr;
      gap:10px;
      margin-top:12px;
    }

    .explain{
      margin-top:12px;
      padding:12px;
      border-radius:12px;
      background:rgba(255,196,0,.07);
      border:1px dashed rgba(255,196,0,.3);
      color:var(--muted);
      font-size:12px;
      line-height:1.35;
    }

    .statsGrid{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:12px;
    }

    .stat{
      background:var(--card2);
      border:1px solid var(--border);
      border-radius:14px;
      padding:12px;
    }

    .stat .val{ font-size:22px; font-weight:800; color:var(--gold); }
    .stat .lbl{ font-size:12px; color:var(--muted); margin-top:4px; }

    .tableWrap{
      width:100%;
      overflow:auto;
      border-radius:14px;
      border:1px solid var(--border);
      background:var(--card2);
    }

    table{
      width:100%;
      border-collapse:collapse;
      min-width:700px;
    }

    th, td{
      padding:10px 12px;
      text-align:left;
      font-size:13px;
      border-bottom:1px solid #1f1f1f;
      white-space:nowrap;
    }

    th{
      background:rgba(255,196,0,.14);
      color:var(--gold);
      font-weight:800;
      position:sticky;
      top:0;
      z-index:1;
    }

    tbody tr:nth-child(odd){ background:var(--row); }
    tbody tr:nth-child(even){ background:var(--row2); }
    tbody tr:hover{ background:#1a1a1a; }

    .pill{
      display:inline-block;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid #333;
      font-size:12px;
      color:var(--muted);
    }

    .pillCome{ border-color:#665200; color:#e8c447; }
    .pillPaid{ border-color:#1d6a3b; color:#63d293; }
    .pillOut{ border-color:#6a1d1d; color:#f3a6a6; }

    .outRow{ opacity:.55; }

    .actionsRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    .miniBtns{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }

    .miniBtn{
      height:32px;
      padding:0 10px;
      border-radius:10px;
      border:1px solid var(--gold);
      background:transparent;
      color:var(--gold);
      font-size:12px;
      cursor:pointer;
    }

    .miniBtn:hover{ background:rgba(255,196,0,.12); }

    .miniBtnDanger{
      border-color:#a33;
      color:#f3a6a6;
    }

    .miniBtnDanger:hover{ background:rgba(163,51,51,.22); }

    .koInput{
      width:70px;
      text-align:center;
    }

    .hintSmall{ color:var(--muted); font-size:12px; margin-top:8px; }

    /* Bulk modal */
    .modalOverlay{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.6);
      display:none;
      align-items:center;
      justify-content:center;
      padding:20px;
      z-index:50;
    }
    .modal{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:16px;
      width:min(900px, 100%);
      padding:16px;
      box-shadow:var(--shadow);
    }
    .modalTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .modalTitle{
      margin:0;
      font-size:18px;
      color:var(--gold);
    }
    .modalBody{
      margin-top:12px;
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:12px;
    }
    .preview{
      border-radius:14px;
      border:1px solid #2d2d2d;
      background:#141414;
      padding:12px;
      min-height:240px;
      overflow:auto;
      font-size:12px;
      color:var(--text);
      white-space:pre-wrap;
    }
    .modalBottom{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:flex-end;
      margin-top:12px;
      flex-wrap:wrap;
    }
    .checkRow{
      display:flex;
      gap:10px;
      align-items:center;
      margin-top:10px;
      color:var(--muted);
      font-size:12px;
    }

    tr.flash td{ outline:2px solid rgba(255,196,0,.55); outline-offset:-2px; }

    @media (max-width: 1100px){
      .mainGrid{ grid-template-columns:1fr; }
      table{ min-width:640px; }
    }

    @media (max-width: 560px){
      .row{ grid-template-columns:1fr; }
      .btnGrid2{ grid-template-columns:1fr; }
      .statsGrid{ grid-template-columns:1fr; }
      .modalBody{ grid-template-columns:1fr; }
    }
  </style>
</head>

<body>
  <div class="container">
    <main class="mainGrid">
      <!-- LEFT COLUMN -->
      <section class="leftCol">
        <div class="card">
          <h2 class="cardTitle">Настройки турнира</h2>
          <div class="row">
            <div class="field">
              <label for="modeSelect">Тип турнира</label>
              <select id="modeSelect">
                <option value="standard">Обычный</option>
                <option value="cascade">CASCADE K.O.</option>
                <option value="bloodhunter">BLOOD HUNTER K.O.</option>
              </select>
            </div>
            <div class="field" id="cascadePhaseWrap" style="display:none;">
              <label for="cascadePhaseSelect">Фаза (CASCADE)</label>
              <select id="cascadePhaseSelect">
                <option value="late">До поздней регистрации (+50 за KO)</option>
                <option value="after">После поздней регистрации (+100 за KO)</option>
                <option value="final">Финальный стол (+200 за KO)</option>
              </select>
            </div>
          </div>
          <div class="explain">
            Пул очков = (оплаченные входы + оплаченные re-entry) × <b style="color:var(--gold);">120</b>.<br>
            ТОП-18 получает очки за место. KO-очки считаются всегда и не зависят от места.
          </div>
        </div>

        <div class="card">
          <h2 class="cardTitle">Добавление игроков</h2>
          <div class="row">
            <div class="field">
              <label for="playerNum">№ игрока</label>
              <input id="playerNum" type="number" min="1" placeholder="№" />
            </div>
            <div class="field">
              <label for="playerName">Ник / Имя</label>
              <input id="playerName" type="text" placeholder="Ник / Имя" />
            </div>
          </div>
          <div class="btnGrid2">
            <button class="btn btnPrimary" id="btnAddPlayer">Добавить игрока</button>
            <button class="btn btnSecondary" id="btnBulkOpen">Загрузить списком</button>
          </div>
          <div class="hintSmall">При добавлении автоматически создаётся основной entry и запись в таблице входов.</div>
        </div>

        <div class="card">
          <h2 class="cardTitle">Импорт / экспорт</h2>
          <div class="btnGrid2">
            <button class="btn btnSecondary" id="btnExportPlayersTxt">Экспорт игроков (.txt)</button>
            <button class="btn btnSecondary" id="btnImportResultsTxt">Импорт результатов (.txt)</button>
          </div>
          <div class="btnGrid1">
            <button class="btn btnSecondary" id="btnExportResultsTxt" disabled>Экспорт результатов (.txt)</button>
          </div>
          <input type="file" id="fileImportResults" accept=".txt" style="display:none;" />
          <div class="explain">
            Экспорт результатов доступен после завершения турнира.
          </div>
        </div>

        <div class="card">
          <h2 class="cardTitle">Итоговые показатели</h2>
          <div class="statsGrid">
            <div class="stat">
              <div class="val" id="statPool">0</div>
              <div class="lbl">Очки в пуле</div>
            </div>
            <div class="stat">
              <div class="val" id="statEntries">0</div>
              <div class="lbl">Входов оплачено</div>
            </div>
            <div class="stat">
              <div class="val" id="statRe">0</div>
              <div class="lbl">Re-entry оплачено</div>
            </div>
            <div class="stat">
              <div class="val" id="statTotal">0</div>
              <div class="lbl">Всего записей</div>
            </div>
          </div>
          <div class="explain" id="statFormula">
            (оплаченные входы + оплаченные re-entry) × 120
          </div>
        </div>

        <div class="card">
          <h2 class="cardTitle">Поиск</h2>
          <div class="row">
            <div class="field">
              <label for="searchInput">Найти по нику или №</label>
              <input id="searchInput" type="text" placeholder="25 или nick" />
            </div>
            <button class="btn btnSecondary" id="btnSearch">Найти</button>
          </div>
          <div class="hintSmall">Поиск прокрутит таблицу игроков справа до совпадения.</div>
        </div>

        <div class="card">
          <h2 class="cardTitle">Входы и Re-entry</h2>
          <div class="tableWrap">
            <table id="entriesTable">
              <thead>
                <tr>
                  <th style="width:70px;">№</th>
                  <th>Игрок</th>
                  <th style="width:120px;">Тип</th>
                  <th style="width:170px;">Статус</th>
                </tr>
              </thead>
              <tbody id="entriesTbody"></tbody>
            </table>
          </div>
          <div class="explain">
            Тап по строке: <b>— → стек выдан → оплачено → —</b>. В расчётах участвуют только <b>оплаченные</b> записи.
          </div>
        </div>

        <div class="card">
          <h2 class="cardTitle">Подсказки администратору</h2>
          <div class="explain" style="border-top:1px dashed rgba(255,196,0,.35); padding-top:12px;">
            <b style="color:var(--gold);">Коротко:</b>
            <ol style="margin:10px 0 10px 18px; padding:0; color:var(--muted);">
              <li>Тап по строке игрока меняет статус: <b>— → пришёл → оплачено</b> (и синхронит entry).</li>
              <li>В пул идут только <b>оплаченные</b> входы и re-entry.</li>
              <li>Re-entry добавляется кнопкой <b>Re-entry +</b> в строке игрока.</li>
              <li>Вылеты отмечаются кнопкой <b>АУТ</b>; финализация возможна при <b>1</b> живом игроке.</li>
              <li>KO-очки считаются отдельно от места и начисляются сразу.</li>
              <li>До финализации очки за место не начисляются, экспорт результатов недоступен.</li>
            </ol>
            <div style="margin-top:10px; padding:10px 12px; border-radius:14px; background:rgba(255,196,0,.08); border:1px solid rgba(255,196,0,.22);">
              ⚠️ Изменения KO/вылетов/оплат/режима сбрасывают финализацию.
            </div>
          </div>
        </div>
      </section>

      <!-- RIGHT COLUMN -->
      <section class="rightCol">
        <div class="card">
          <h2 class="cardTitle">Кнопки управления турниром</h2>
          <div class="actionsRow">
            <button class="btn btnPrimary" id="btnFinalize">Завершить турнир и начислить очки</button>
            <button class="btn btnDanger" id="btnReset">Сбросить турнир</button>
          </div>
          <div class="hintSmall">Кнопка завершения активна только при одном игроке в игре.</div>
        </div>

        <div class="card">
          <h2 class="cardTitle">Список игроков</h2>
          <div class="tableWrap">
            <table id="playersTable">
              <thead>
                <tr>
                  <th style="width:70px;">№</th>
                  <th>Игрок</th>
                  <th style="width:140px;">Статус</th>
                  <th style="width:110px;">KO</th>
                  <th style="width:120px;">Очки KO</th>
                  <th style="width:140px;">Очки за место</th>
                  <th style="width:120px;">Итого</th>
                  <th style="width:360px;">Действия</th>
                </tr>
              </thead>
              <tbody id="playersTbody"></tbody>
            </table>
          </div>
          <div class="explain" style="margin-top:10px;">
            Тап по строке игрока меняет статус: <b>— → пришёл → оплачено → —</b>.
            Клики по кнопкам/KO не меняют статус.
          </div>
        </div>
      </section>
    </main>
  </div>

  <!-- Bulk modal -->
  <div class="modalOverlay" id="modalOverlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modalTop">
        <h3 class="modalTitle">Загрузить игроков списком</h3>
        <button class="btn btnSecondary" id="btnModalClose" style="height:38px;">Закрыть</button>
      </div>

      <div class="modalBody">
        <div>
          <label>Вставьте список (по одному игроку в строке)</label>
          <textarea id="bulkTextarea" placeholder="Примеры:
25 Юрич
12, Karavan
7 - Ame
14: Scouser
33"></textarea>

          <div class="checkRow">
            <input type="checkbox" id="chkOverwrite" />
            <label for="chkOverwrite" style="margin:0; font-size:12px;">Перезаписывать имя, если номер уже есть</label>
          </div>
        </div>

        <div>
          <label>Предпросмотр добавления</label>
          <div class="preview" id="bulkPreview">Вставьте строки слева — здесь появится предпросмотр.</div>
        </div>
      </div>

      <div class="modalBottom">
        <button class="btn btnSecondary" id="btnBulkCancel">Отмена</button>
        <button class="btn btnPrimary" id="btnBulkApply">Добавить</button>
      </div>
    </div>
  </div>

  <script>
    (function(){
      const LS_KEY = "tournament_state_static_v3";
      const ENTRY_POINTS = 120;

      const TOP18_PERCENTS = [
        25.0, 13.1, 9.5, 7.5, 6.3, 5.5, 4.8, 4.3, 3.9,
        2.6, 2.5, 2.4, 2.3, 2.2, 2.1, 2.1, 2.0, 1.9
      ];

      const PLAYER_STATUS_LABEL = s => s===2 ? "оплачено" : (s===1 ? "пришёл" : "—");
      const ENTRY_STATUS_LABEL  = s => s===2 ? "оплачено" : (s===1 ? "стек выдан" : "—");

      const modeSelect = document.getElementById("modeSelect");
      const cascadePhaseWrap = document.getElementById("cascadePhaseWrap");
      const cascadePhaseSelect = document.getElementById("cascadePhaseSelect");

      const playerNum = document.getElementById("playerNum");
      const playerName = document.getElementById("playerName");

      const btnAddPlayer = document.getElementById("btnAddPlayer");
      const btnBulkOpen = document.getElementById("btnBulkOpen");
      const btnExportPlayersTxt = document.getElementById("btnExportPlayersTxt");

      const btnImportResultsTxt = document.getElementById("btnImportResultsTxt");
      const fileImportResults = document.getElementById("fileImportResults");
      const btnExportResultsTxt = document.getElementById("btnExportResultsTxt");

      const statPool = document.getElementById("statPool");
      const statEntries = document.getElementById("statEntries");
      const statRe = document.getElementById("statRe");
      const statTotal = document.getElementById("statTotal");
      const statFormula = document.getElementById("statFormula");

      const searchInput = document.getElementById("searchInput");
      const btnSearch = document.getElementById("btnSearch");

      const entriesTbody = document.getElementById("entriesTbody");
      const playersTbody = document.getElementById("playersTbody");

      const btnFinalize = document.getElementById("btnFinalize");
      const btnReset = document.getElementById("btnReset");

      const modalOverlay = document.getElementById("modalOverlay");
      const btnModalClose = document.getElementById("btnModalClose");
      const btnBulkCancel = document.getElementById("btnBulkCancel");
      const btnBulkApply = document.getElementById("btnBulkApply");
      const bulkTextarea = document.getElementById("bulkTextarea");
      const bulkPreview = document.getElementById("bulkPreview");
      const chkOverwrite = document.getElementById("chkOverwrite");

      const state = normalizeState(loadState());

      function newState(){
        return {
          mode: "standard",
          cascadePhase: "late",
          players: [],
          entries: [],
          outCounter: 0,
          finalized: false
        };
      }

      function uid(){
        return Math.random().toString(16).slice(2) + Date.now().toString(16);
      }

      function saveState(){
        try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); }catch(e){}
      }
      function loadState(){
        try{
          const raw = localStorage.getItem(LS_KEY);
          if(!raw) return null;
          return JSON.parse(raw);
        }catch(e){ return null; }
      }

      function normalizeState(raw){
        const base = newState();
        if(!raw || typeof raw !== "object") return base;
        const out = { ...base, ...raw };
        out.players = Array.isArray(raw.players) ? raw.players.map(p=>({
          num: Number(p.num),
          name: String(p.name || `Player #${p.num}`),
          status: Number.isFinite(p.status) ? p.status : 0,
          ko: Number.isFinite(p.ko) ? p.ko : 0,
          outIndex: (p.outIndex==null) ? null : Number(p.outIndex),
          place: (p.place==null) ? null : Number(p.place),
          placePoints: Number.isFinite(p.placePoints) ? p.placePoints : 0,
          koPoints: Number.isFinite(p.koPoints) ? p.koPoints : 0,
          totalPoints: Number.isFinite(p.totalPoints) ? p.totalPoints : 0
        })) : [];
        out.entries = Array.isArray(raw.entries) ? raw.entries.map(e=>({
          id: String(e.id || uid()),
          num: Number(e.num),
          type: e.type === "re" ? "re" : "entry",
          status: Number.isFinite(e.status) ? e.status : 0
        })) : [];
        out.outCounter = Number.isFinite(raw.outCounter) ? raw.outCounter : 0;
        out.finalized = !!raw.finalized;
        out.mode = raw.mode === "cascade" || raw.mode === "bloodhunter" ? raw.mode : "standard";
        out.cascadePhase = raw.cascadePhase === "after" || raw.cascadePhase === "final" ? raw.cascadePhase : "late";
        return out;
      }

      function syncModeUI(){
        modeSelect.value = state.mode;
        cascadePhaseSelect.value = state.cascadePhase;
        cascadePhaseWrap.style.display = (state.mode === "cascade") ? "" : "none";
      }

      modeSelect.addEventListener("change", ()=>{
        state.mode = modeSelect.value;
        if(state.finalized){ unfinalize(); }
        recomputeAllPoints(true);
        saveState();
        render();
      });

      cascadePhaseSelect.addEventListener("change", ()=>{
        state.cascadePhase = cascadePhaseSelect.value;
        if(state.finalized){ unfinalize(); }
        recomputeAllPoints(true);
        saveState();
        render();
      });

      btnAddPlayer.addEventListener("click", ()=>{
        const num = parseInt(playerNum.value,10);
        const name = (playerName.value||"").trim();

        if(!num || num<=0){ alert("Введите номер игрока."); playerNum.focus(); return; }
        if(!name){ alert("Введите ник/имя игрока."); playerName.focus(); return; }
        if(state.players.some(p=>p.num===num)){ alert("Игрок с таким номером уже существует."); return; }

        addPlayer(num, name);
        playerNum.value=""; playerName.value="";
        playerNum.focus();
        saveState();
        render();
      });

      function addPlayer(num,name){
        state.players.push({
          num, name,
          status:0,
          ko:0,
          outIndex:null,
          place:null,
          placePoints:0,
          koPoints:0,
          totalPoints:0
        });
        state.entries.push({ id:uid(), num, type:"entry", status:0 });
      }

      // Bulk modal
      btnBulkOpen.addEventListener("click", ()=> openModal(true));
      btnModalClose.addEventListener("click", ()=> openModal(false));
      btnBulkCancel.addEventListener("click", ()=> openModal(false));
      modalOverlay.addEventListener("click", (e)=>{ if(e.target===modalOverlay) openModal(false); });

      function openModal(open){
        modalOverlay.style.display = open ? "flex" : "none";
        modalOverlay.setAttribute("aria-hidden", open ? "false" : "true");
        if(open){
          bulkTextarea.value="";
          chkOverwrite.checked=false;
          bulkPreview.textContent="Вставьте строки слева — здесь появится предпросмотр.";
          setTimeout(()=> bulkTextarea.focus(), 50);
        }
      }

      function parseBulkLines(text){
        const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
        const out=[];
        for(const line of lines){
          const m = line.match(/^(\d+)\s*(?:[,:\-]\s*|\s+)?(.+)?$/);
          if(!m) continue;
          const num = parseInt(m[1],10);
          let name = (m[2]||"").trim();
          if(!name) name = `Player #${num}`;
          out.push({num,name});
        }
        return out;
      }

      function updateBulkPreview(){
        const items = parseBulkLines(bulkTextarea.value);
        if(items.length===0){ bulkPreview.textContent="Нет распознанных строк."; return; }
        const overwrite = chkOverwrite.checked;
        const lines = items.slice(0,200).map(x=>{
          const exists = state.players.some(p=>p.num===x.num);
          const mark = exists ? (overwrite ? "обновит" : "пропустит") : "добавит";
          return `${x.num} — ${x.name}  [${mark}]`;
        });
        bulkPreview.textContent = lines.join("\n") + (items.length>200 ? "\n…(ещё строки скрыты)" : "");
      }

      bulkTextarea.addEventListener("input", updateBulkPreview);
      chkOverwrite.addEventListener("change", updateBulkPreview);

      btnBulkApply.addEventListener("click", ()=>{
        const items = parseBulkLines(bulkTextarea.value);
        if(items.length===0){ alert("Список пуст или не распознан."); return; }
        const overwrite = chkOverwrite.checked;
        let added=0, updated=0, skipped=0;

        for(const it of items){
          const p = state.players.find(p=>p.num===it.num);
          if(p){
            if(overwrite){ p.name=it.name; updated++; }
            else skipped++;
          }else{
            addPlayer(it.num, it.name);
            added++;
          }
        }

        saveState();
        render();
        openModal(false);
        alert(`Готово. Добавлено: ${added}. Обновлено: ${updated}. Пропущено: ${skipped}.`);
      });

      // Export players TXT
      btnExportPlayersTxt.addEventListener("click", ()=>{
        const lines=["№ Ник"];
        const sorted=[...state.players].sort((a,b)=>a.num-b.num);
        for(const p of sorted){
          lines.push(`${p.num} ${p.name}`);
        }
        downloadText(lines.join("\n"), makeFileName("players","txt"));
      });

      // Import results TXT
      btnImportResultsTxt.addEventListener("click", ()=>{
        fileImportResults.value="";
        fileImportResults.click();
      });

      fileImportResults.addEventListener("change", async ()=>{
        const file = fileImportResults.files && fileImportResults.files[0];
        if(!file) return;
        const text = await file.text();
        importResultsFromTxt(text);
      });

      // Export results TXT
      btnExportResultsTxt.addEventListener("click", ()=>{
        const txt = buildResultsTxt();
        downloadText(txt, makeFileName("results","txt"));
      });

      function importResultsFromTxt(text){
        const lines = text.split(/\r?\n/);
        const headerIdx = lines.findIndex(l => l.toLowerCase().includes("место") && l.includes("|") && l.toLowerCase().includes("итого"));
        if(headerIdx===-1){
          alert("Не найден блок таблицы результатов. Нужна строка: 'МЕСТО | НИК | ... | ИТОГО'.");
          return;
        }
        const headerParts = lines[headerIdx].split("|").map(s=>s.trim().toLowerCase());
        const isOldFormat = headerParts.includes("№") || headerParts.includes("entry") || headerParts.includes("re");
        const parseCell = (value)=>{
          const v=(value||"").trim();
          if(!v || v==="-" ) return 0;
          const n=parseInt(v,10);
          return Number.isFinite(n)?n:0;
        };
        const rows=[];
        for(let i=headerIdx+1;i<lines.length;i++){
          const line = lines[i].trim();
          if(!line || !line.includes("|")) continue;
          const parts = line.split("|").map(s=>s.trim());
          if(isOldFormat){
            if(parts.length<9) continue;
            const place = parseInt(parts[0],10);
            const num = parseInt(parts[1],10);
            const name = parts[2] || `Player #${num}`;
            const ko = parseCell(parts[5]);
            const koPoints = parseCell(parts[6]);
            const placePoints = parseCell(parts[7]);
            const totalPoints = parseCell(parts[8]);
            if(!place || !num) continue;
            rows.push({place,num,name,ko,koPoints,placePoints,totalPoints});
          }else{
            if(parts.length<6) continue;
            const place = parseInt(parts[0],10);
            const name = parts[1];
            const ko = parseCell(parts[2]);
            const koPoints = parseCell(parts[3]);
            const placePoints = parseCell(parts[4]);
            const totalPoints = parseCell(parts[5]);
            if(!place) continue;
            const num = place;
            rows.push({place,num,name: name || `Player #${num}`,ko,koPoints,placePoints,totalPoints});
          }
        }
        if(rows.length===0){ alert("Не удалось распознать строки результатов."); return; }

        Object.assign(state, newState());
        state.finalized = true;

        for(const r of rows){
          addPlayer(r.num, r.name);
          const p = state.players.find(x=>x.num===r.num);
          p.ko=r.ko;
          p.koPoints=r.koPoints;
          p.placePoints=r.placePoints;
          p.totalPoints=r.totalPoints;
          p.place=r.place;
          p.status=2;
        }

        const others = rows.filter(r=>r.place!==1).sort((a,b)=>a.place-b.place);
        state.outCounter = others.length;
        let outIndex = others.length;
        for(const r of others){
          const p = state.players.find(x=>x.num===r.num);
          p.outIndex = outIndex--;
        }
        const win = rows.find(r=>r.place===1);
        if(win){
          const p = state.players.find(x=>x.num===win.num);
          p.outIndex = null;
        }

        for(const e of state.entries) e.status=2;

        saveState(); render();
        alert(`Результаты импортированы: ${rows.length} строк(и).`);
      }

      // Search
      btnSearch.addEventListener("click", doSearch);
      searchInput.addEventListener("keydown", (e)=>{ if(e.key==="Enter") doSearch(); });

      function doSearch(){
        const q=(searchInput.value||"").trim().toLowerCase();
        if(!q) return;
        let target=null;
        const num=parseInt(q,10);
        if(num) target = state.players.find(p=>p.num===num);
        if(!target) target = state.players.find(p=>(p.name||"").toLowerCase().includes(q));
        if(!target){ alert("Не найдено."); return; }
        const row=document.querySelector(`tr[data-player-num="${target.num}"]`);
        if(row){
          row.scrollIntoView({behavior:"smooth", block:"center"});
          row.classList.add("flash");
          setTimeout(()=>row.classList.remove("flash"), 900);
        }
      }

      // Entries row tap
      entriesTbody.addEventListener("click", (e)=>{
        const tr=e.target.closest("tr");
        if(!tr) return;
        const id=tr.getAttribute("data-entry-id");
        const entry=state.entries.find(x=>x.id===id);
        if(!entry) return;

        entry.status = (entry.status+1)%3;

        if(entry.type==="entry"){
          const p=state.players.find(p=>p.num===entry.num);
          if(p) p.status = entry.status;
        }

        if(state.finalized){ unfinalize(); }

        recomputeAllPoints(true);
        saveState(); render();
      });

      // Players row tap (ignore buttons/inputs)
      playersTbody.addEventListener("click", (e)=>{
        if(e.target.closest("button") || e.target.closest("input")) return;
        const tr=e.target.closest("tr");
        if(!tr) return;
        const num=parseInt(tr.getAttribute("data-player-num"),10);
        const p=state.players.find(x=>x.num===num);
        if(!p) return;

        p.status=(p.status+1)%3;

        const main=state.entries.find(x=>x.num===p.num && x.type==="entry");
        if(main) main.status=p.status;

        if(state.finalized){ unfinalize(); }

        recomputeAllPoints(true);
        saveState(); render();
      });

      // Finalize / reset
      btnFinalize.addEventListener("click", finalizeTournament);

      btnReset.addEventListener("click", ()=>{
        if(!confirm("Сбросить турнир? Все данные будут удалены.")) return;
        Object.assign(state, newState());
        syncModeUI();
        saveState(); render();
      });

      function countPaid(type){ return state.entries.filter(e=>e.type===type && e.status===2).length; }
      function countTotal(type){ return state.entries.filter(e=>e.type===type).length; }
      function computePoolPoints(){ return (countPaid("entry")+countPaid("re"))*ENTRY_POINTS; }

      function koPointsForPlayer(p){
        const ko=Math.max(0, parseInt(p.ko,10)||0);
        if(state.mode==="standard") return 0;
        if(state.mode==="cascade"){
          const per = (state.cascadePhase==="late") ? 50 : (state.cascadePhase==="after") ? 100 : 200;
          return ko*per;
        }
        let pts=0;
        for(let i=1;i<=ko;i++){
          if(i===1) pts+=50;
          else if(i===2) pts+=75;
          else if(i===3) pts+=100;
          else pts+=150;
        }
        return pts;
      }

      function recomputeAllPoints(keepPlace){
        for(const p of state.players){
          p.ko = Math.max(0, parseInt(p.ko,10)||0);
          p.koPoints = koPointsForPlayer(p);
          if(!keepPlace && !state.finalized){
            p.placePoints=0; p.place=null;
          }
          p.totalPoints = (p.placePoints||0) + (p.koPoints||0);
        }
      }

      function finalizeTournament(){
        const alive = state.players.filter(p=>p.outIndex==null);
        if(alive.length!==1){
          alert("Для завершения турнира должен остаться ровно 1 игрок «в игре». Отметьте вылеты кнопкой «АУТ». ");
          return;
        }

        const pool = computePoolPoints();
        const winner=alive[0];

        const out = state.players
          .filter(p=>p.outIndex!=null)
          .sort((a,b)=> (b.outIndex-a.outIndex));

        winner.place=1;
        let place=2;
        for(const p of out){ p.place=place++; }

        for(const p of state.players){
          if(p.place && p.place>=1 && p.place<=18){
            const percent = TOP18_PERCENTS[p.place-1]/100;
            p.placePoints = Math.round(pool*percent);
          }else{
            p.placePoints=0;
          }
        }

        recomputeAllPoints(true);
        state.finalized=true;

        saveState(); render();
        alert("Турнир завершён. Очки начислены. Можно экспортировать результаты (TXT).");
      }

      function buildResultsTxt(){
        const pool=computePoolPoints();
        const paidEntry=countPaid("entry");
        const paidRe=countPaid("re");
        const modeLabel = state.mode==="standard" ? "Обычный" : state.mode==="cascade" ? "CASCADE K.O." : "BLOOD HUNTER K.O.";
        const phaseLabel = state.cascadePhase==="late" ? "До поздней регистрации (+50 за KO)"
                        : state.cascadePhase==="after" ? "После поздней регистрации (+100 за KO)"
                        : "Финальный стол (+200 за KO)";

        const lines=[];
        lines.push("РЕЗУЛЬТАТЫ ТУРНИРА");
        lines.push("");
        lines.push(`Тип турнира: ${modeLabel}`);
        if(state.mode==="cascade") lines.push(`Фаза: ${phaseLabel}`);
        lines.push("");
        lines.push("Пул очков:");
        lines.push("(оплаченные входы + оплаченные re-entry) × 120");
        lines.push(`(${paidEntry} + ${paidRe}) × 120 = ${pool}`);
        lines.push("");
        lines.push("МЕСТО | НИК | КО | ОЧКИ КО | ОЧКИ ЗА МЕСТО | ИТОГО");

        const rows=[...state.players].filter(p=>p.place!=null).sort((a,b)=>a.place-b.place);

        for(const p of rows){
          lines.push([
            p.place,
            p.name,
            p.ko||0,
            p.koPoints||0,
            p.placePoints||0,
            p.totalPoints||0
          ].join(" | "));
        }
        return lines.join("\n");
      }

      function render(){
        syncModeUI();

        const pool = computePoolPoints();
        const entriesAll = countTotal("entry");
        const reAll = countTotal("re");
        const paidEntry = countPaid("entry");
        const paidRe = countPaid("re");

        statPool.textContent = String(pool);
        statEntries.textContent = String(paidEntry);
        statRe.textContent = String(paidRe);
        statTotal.textContent = String(entriesAll + reAll);

        statFormula.textContent =
          `(оплаченные входы + оплаченные re-entry) × 120 = (${paidEntry} + ${paidRe}) × 120 = ${pool}`;

        renderEntries();
        renderPlayers();

        btnExportResultsTxt.disabled = !state.finalized;
        btnFinalize.disabled = (state.players.filter(p=>p.outIndex==null).length !== 1);

        saveState();
      }

      function renderEntries(){
        const playersMap = new Map(state.players.map(p=>[p.num,p]));
        const rows=[...state.entries].sort((a,b)=>{
          if(a.num!==b.num) return a.num-b.num;
          if(a.type!==b.type) return (a.type==="entry") ? -1 : 1;
          return a.id.localeCompare(b.id);
        });

        entriesTbody.innerHTML="";
        for(const e of rows){
          const p=playersMap.get(e.num);
          const tr=document.createElement("tr");
          tr.setAttribute("data-entry-id", e.id);
          tr.innerHTML=`
            <td>${e.num}</td>
            <td>${escapeHtml(p ? p.name : ("Player #"+e.num))}</td>
            <td>${e.type==="entry" ? "вход" : "re-entry"}</td>
            <td><span class="pill">${ENTRY_STATUS_LABEL(e.status)}</span></td>
          `;
          entriesTbody.appendChild(tr);
        }
      }

      function renderPlayers(){
        const alive = state.players.filter(p=>p.outIndex==null).sort((a,b)=>a.num-b.num);
        const out = state.players.filter(p=>p.outIndex!=null).sort((a,b)=> (b.outIndex-a.outIndex));
        const ordered=[...alive, ...out];

        playersTbody.innerHTML="";

        for(const p of ordered){
          const tr=document.createElement("tr");
          tr.setAttribute("data-player-num", p.num);
          if(p.outIndex!=null) tr.classList.add("outRow");

          const statusText = (p.outIndex!=null) ? "аут" : PLAYER_STATUS_LABEL(p.status);
          const statusClass = (p.outIndex!=null) ? "pillOut" : (p.status===2 ? "pillPaid" : (p.status===1 ? "pillCome" : ""));

          const entryAll = state.entries.filter(e=>e.num===p.num && e.type==="entry").length;
          const reAll = state.entries.filter(e=>e.num===p.num && e.type==="re").length;
          const entryPaid = state.entries.filter(e=>e.num===p.num && e.type==="entry" && e.status===2).length;
          const rePaid = state.entries.filter(e=>e.num===p.num && e.type==="re" && e.status===2).length;

          const koPoints = p.koPoints||0;
          const placePoints = p.placePoints||0;
          const totalPoints = p.totalPoints||0;
          const placeBadge = p.place ? `#${p.place}` : "—";

          const outBtnLabel = (p.outIndex==null) ? "АУТ" : "Отмена АУТ";

          tr.innerHTML=`
            <td>${p.num}</td>
            <td>${escapeHtml(p.name)}</td>
            <td><span class="pill ${statusClass}">${statusText}</span></td>
            <td><input class="koInput" type="number" min="0" value="${p.ko||0}" data-ko-num="${p.num}"></td>
            <td>
              <div style="font-weight:900;color:var(--gold);">${koPoints}</div>
              <div style="color:var(--muted);font-size:11px;margin-top:2px;">KO</div>
            </td>
            <td>
              <div style="font-weight:900;color:var(--gold);">${placePoints}</div>
              <div style="color:var(--muted);font-size:11px;margin-top:2px;">Место ${placeBadge}</div>
            </td>
            <td>
              <div style="font-weight:900;color:var(--gold);">${totalPoints}</div>
              <div style="color:var(--muted);font-size:11px;margin-top:2px;">Итого</div>
            </td>
            <td>
              <div style="color:var(--muted);font-size:11px;margin-bottom:6px;">
                E ${entryPaid}/${entryAll} · R ${rePaid}/${reAll}
              </div>
              <div class="miniBtns">
                <button class="miniBtn" data-action="re" data-num="${p.num}">Re-entry +</button>
                <button class="miniBtn" data-action="out" data-num="${p.num}">${outBtnLabel}</button>
                <button class="miniBtn miniBtnDanger" data-action="del" data-num="${p.num}">Удалить</button>
              </div>
            </td>
          `;
          playersTbody.appendChild(tr);
        }

        playersTbody.querySelectorAll('input[data-ko-num]').forEach(inp=>{
          inp.addEventListener("click", e=>e.stopPropagation());
          inp.addEventListener("input", e=>{
            e.stopPropagation();
            const num=parseInt(inp.getAttribute("data-ko-num"),10);
            const p=state.players.find(x=>x.num===num);
            if(!p) return;
            p.ko = Math.max(0, parseInt(inp.value,10)||0);
            if(state.finalized){ unfinalize(); }
            recomputeAllPoints(true);
            saveState(); render();
          });
        });

        playersTbody.querySelectorAll('button[data-action]').forEach(btn=>{
          btn.addEventListener("click", (e)=>{
            e.stopPropagation();
            const action=btn.getAttribute("data-action");
            const num=parseInt(btn.getAttribute("data-num"),10);
            const p=state.players.find(x=>x.num===num);
            if(!p) return;

            if(action==="re"){
              state.entries.push({ id:uid(), num:p.num, type:"re", status:0 });
              if(state.finalized){ unfinalize(); }
            }
            if(action==="out"){
              if(p.outIndex==null){ state.outCounter+=1; p.outIndex=state.outCounter; }
              else p.outIndex=null;
              if(state.finalized){ unfinalize(); }
            }
            if(action==="del"){
              if(!confirm(`Удалить игрока #${p.num} (${p.name})?`)) return;
              state.players = state.players.filter(x=>x.num!==p.num);
              state.entries = state.entries.filter(en=>en.num!==p.num);
              if(state.finalized){ unfinalize(); }
            }

            recomputeAllPoints(true);
            saveState(); render();
          });
        });
      }

      function unfinalize(){
        state.finalized=false;
        btnExportResultsTxt.disabled=true;
        for(const pl of state.players){
          pl.place=null; pl.placePoints=0; pl.totalPoints=0;
        }
      }

      // Helpers
      function downloadText(text, filename){
        const blob=new Blob([text], {type:"text/plain;charset=utf-8"});
        const url=URL.createObjectURL(blob);
        const a=document.createElement("a");
        a.href=url; a.download=filename;
        document.body.appendChild(a);
        a.click(); a.remove();
        setTimeout(()=>URL.revokeObjectURL(url), 3000);
      }
      function pad2(n){ return String(n).padStart(2,"0"); }
      function makeFileName(prefix, ext){
        const d=new Date();
        return `${prefix}_${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}.${ext}`;
      }
      function escapeHtml(str){
        return String(str)
          .replaceAll("&","&amp;")
          .replaceAll("<","&lt;")
          .replaceAll(">","&gt;")
          .replaceAll('"',"&quot;")
          .replaceAll("'","&#039;");
      }

      syncModeUI();
      recomputeAllPoints(true);
      render();
      saveState();

      document.addEventListener("keydown", (e)=>{
        if(e.key==="Escape" && modalOverlay.style.display==="flex") openModal(false);
      });
    })();
  </script>
</body>
</html>
